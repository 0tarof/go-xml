// Package xsdgen generates Go source code from xml schema documents.
//
// The xsdgen package generates type declarations and accompanying
// methods for marshalling and unmarshalling XML elements that adhere
// to an XML schema. The source code generation is configurable, and can
// be passed through user-defined filters.
//
// Code generated by the xsdgen package is self-contained; only the Go
// standard library is used. All types generated by the xsdgen package
// can be unmarshalled into by the standard encoding/xml package. Where
// neccessary, methods are generated to satisfy the interfaces used by
// encoding/xml. For instance, the following schema
//
//	<xs:schema targetNamespace="http://example.com/ip/">
// 	  <xs:complexType name="StringArray">
// 	    <xs:complexContent>
// 	      <xs:restriction base="soapenc:Array">
// 	        <xs:attribute ref="soapenc:arrayType" wsdl:arrayType="soapenc:string[]" />
// 	      </xs:restriction>
// 	    </xs:complexContent>
// 	  </xs:complexType>
// 	</xs:schema>
//
// Generates the following Go code:
//
// 	type StringArray []string
// 	func MarshalXML(e *xml.Encoder, start xml.StartElement) error {
// 		tag := xml.StartElement{Name: xml.Name{"", "item"}}
// 		for _, elt := range *a {
// 			if err := e.EncodeElement(elt, tag); err != nil {
// 				return err
// 			}
// 		}
// 		return nil
// 	}
// 	func (a *StringArray) UnmarshalXML(d *xml.Decoder, start xml.StartElement) (err error) {
// 		var tok xml.Token
// 		var itemTag = xml.Name{"", ",any"}
// 		for tok, err = d.Token(); err == nil; tok, err = d.Token() {
// 			if tok, ok := tok.(xml.StartElement); ok {
// 				var item string
// 				if itemTag.Local != ",any" && itemTag != tok.Name {
// 					err = d.Skip()
// 					continue
// 				}
// 				if err = d.DecodeElement(&item, &tok); err == nil {
// 					*a = append(*a, item)
// 				}
// 			}
// 			if _, ok := tok.(xml.EndElement); ok {
// 				break
// 			}
// 		}
// 		return err
// 	}
package xsdgen
